% L0 is a pure language

\section{Rewriting}

The straight-forward way of testing associativity is by \emph{rewriting}. We
can test whether $\oplus$ is associative by considering whether $\p{x \oplus y}
\oplus z$ and $x \oplus \p{y \oplus z}$ can be rewritten to be syntactically
equivalent.

For instance, if $\oplus\p{x,y} = x\lt c \lp y \lt c$, for some constant $c\in
S$, we consider whether the equality in \referToFigure{first-equality} holds
for all $x$, $y$, and $z$.

\begin{figure*}[htbp!]
\begin{align*}
\p{x\lt c \lp y\lt c}\lt c \lp z\lt c &= x\lt c \lp \p{y\lt c \lp z\lt c}\lt c \\
x\lt c \lt c \lp y\lt c \lt c \lp z\lt c &= x\lt c \lp y\lt c \lt c \lp z\lt c \lt c \\
x\lt c \lt c \lp z\lt c &= x\lt c \lp z\lt c \lt c
\end{align*}
\caption[]{If $\oplus\p{x,y}=x\lt c \lp y\lt c$ is associative, the above
should hold for all $x$, $y$ and $z$.}
\label{figure:first-equality}
\end{figure*}

This analysis requires \emph{rewriting} both expressions as a \emph{sum of
products}, followed by \emph{common term elimination}. If $c$ is a constant, we
can complete the analysis by \emph{constant folding}, and considering whether
the left-hand side is syntactically equivalent to the right-hand side.

Note, we didn't need to utilize the properties that addition and multiplication
are also commutative.  This is because the variables appear in the same order
on either side of the equality. So long as our rewriting rules respect this
order, we can proceed freely. 

Another property that our rewriting rules must respect are overflows. We should
keep in mind that we're dealing with modulo arithmetic.

Unfolding all parens is straight-forward. Unparenthesise in a bottom-up
fashion. An expression is represented as a tree, traverse the tree, identify
all parentheses. Sort the parenetheses by depth in the tree. Take the
parentheses in order. Apply parenthesing rewritings first.

No need to unfold all parens, just all those that replace variables. Let x and
y be the variable names of the arguments in question. Let z be variable name
that does not occur in the program text of f. Let f1 be the original program
text f. Let f2 be the original program text f with y replaced by z, and x
replaced by (f1) (in that order). Let f3 be the original program text f with y
replaced by z, and x replaced by y (in that order). Let f4 be the original
program text f with y replaced by (f3). This leads to exactly 4 parentheses
that we wish unfolded. To do this, we follow the P- rewriting rules.

We need to use a work queue. Mention precedance rules.

The general algorithm: is the operator chain-associative? is the operator
distributive over any other operators in L0?

We summarise the rules for arithmetic operators in
\referToFigure{rewriting-arithop}. The approach to constructing the rules in
general is to consider every operator $\oplus$, associative under chaining. For
each $\oplus$ we consider whether the $\oplus$ is distributive under every
$\otimes$. This will allow us to apply the rules by following the rules of
precedence of the language. We add an additional rule to transform chains.

We don't need to define rules for expanding parentheses over non-assoc
operators, as such functions won't associate anyways.

\begin{figure*}[htbp!]

\[
\begin{matrix}
\proc{P-Plus-Plus}:{\over
\p{e_1 \lp e_2}\lp e \rightarrow e_1 \lp \p{ e_2 \lp e }
}\\
\proc{P-Times-Times}:{\over
\p{e_1\lt e_2}\lt e \rightarrow e_1 \lt \p{ e_2 \lt e }
}\\
\end{matrix}
\]
\caption[]{Rewriting rules for chainable operators.}
\label{figure:rewriting-arithop}
\end{figure*}


\begin{figure*}[htbp!]

\[
\begin{matrix}
\proc{P-Times-Mod-R}:{\over
\p{e_1 \lmod e_2}\lt e \rightarrow \p{ e_1 \lt e } \lmod \p{ e_2 \lt e }
}\\
\proc{P-Times-Plus-R}:{\over
\p{e_1 \lp e_2}\lt e \rightarrow \p{ e_1 \lt e } \lp \p{ e_2 \lt e }
}\\
\proc{P-Times-Minus-R}:{\over
\p{e_1 \lm e_2}\lt e \rightarrow \p{ e_1 \lt e } \lp \lneg\p{ e_2 \lt e }
}\\
\proc{P-Times-ShiftL-R}:{\over
\p{e_1 \LBSL e_2}\lt e \rightarrow \p{ e_1 \lt e } \LBSL e_2
}
\end{matrix}
\]
\caption[]{Rewriting rules for arithmetic operators. The above are only
right-distributions. Left-distributions are symmetrical. Note, bit shifting to
the left by $e$ is equivalent to multiplying by $2^e$.}
\label{figure:rewriting-arithop}
\end{figure*}


%\begin{figure*}[htbp!]

%\begin{align*}
%\proc{P-PlusR}:{\over
%\p{e_1 \lp e_2 \lp \cdots \lp e_n} \lp e \rightarrow e_1 \lp e_2 \lp \cdots \lp e_n \lp e
%}\p{n\geq 2}\\
%\proc{P-PlusL}:{\over
%e \lp \p{e_1 \lp e_2 \lp \cdots \lp e_n} \rightarrow e \lp e_1 \lp e_2 \lp \cdots \lp e_n
%}\p{n\geq 2}
%\end{align*}

%\begin{align*}
%\proc{P-TimesR}:{\over
%\p{e_1 \lp e_2 \lp \cdots \lp e_n} \lt e \rightarrow e_1\lt e \lp e_2\lt e \lp
%\cdots \lp e_n \lt e
%}\p{n\geq 2}\\
%\proc{P-TimesL}:{\over
%e\lt\p{e_1 \lp e_2 \lp \cdots \lp e_n} \rightarrow e\lt e_1 \lp e\lt e_2 \lp \cdots
%\lp e\lt e_n
%}\p{n\geq 2}
%\end{align*}

%\begin{align*}
%\proc{Minus}:{\over
%e_1 \lm e_2 \rightarrow e_1 \lp \lneg e_2
%}
%\end{align*}

%\begin{align*}
%\proc{P-Negate}:{\over
%\lneg\p{e_1 \lp e_2 \lp \cdots \lp e_n} \rightarrow \lneg e_1 \lp \lneg e_2 \lp \cdots
%\lp \lneg e_n
%}\p{n\geq 2}
%\end{align*}


%\caption[]{Rewriting rules for arithmetic operators.}
%\label{figure:rewriting-arithop}
%\end{figure*}


\begin{figure*}[htbp!]
\begin{align*}
\proc{P-AndR}:{\over
\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \LAND e \rightarrow e_1\LAND e \LOR
e_2\LAND e \LOR \cdots \LOR e_n \LAND e
}\p{n\geq 2}\\
\proc{P-AndL}:{\over
e\LAND\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \rightarrow e\LAND e_1 \LOR e\LAND
e_2 \LOR \cdots
\LOR e\LAND e_n
}\p{n\geq 2}
\end{align*}

\begin{align*}
\proc{P-OrR}:{\over
\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \LOR e \rightarrow e_1 \LOR e_2 \LOR
\cdots \LOR e_n \LOR e
}\p{n\geq 2}\\
\proc{P-OrL}:{\over
e \LOR \p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \rightarrow e \LOR e_1 \LOR e_2
\LOR \cdots \LOR e_n
}\p{n\geq 2}
\end{align*}

\begin{align*}
\proc{P-Not}:{\over
\LNOT\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \rightarrow \LNOT e_1 \LOR \LNOT e_2
\LOR \cdots \LOR \LNOT e_n
}\p{n\geq 2}
\end{align*}

\caption[]{Rewriting rules for logical operators.}
\label{figure:rewriting-logop}
\end{figure*}

For bitwise operators we simply use Light's associativity test. 

For the \LMIN{} and \LMAX{} functions, the rewrite rules are a bit more
complicated. First off, we need to do some extra work

\begin{figure*}[htbp!]
\begin{align*}
\proc{S-Min}:{\over \LMIN\p{e_y, e_x} \rightarrow \LMIN\p{e_x,e_y} }
\end{align*}

\begin{align*}
\proc{P-MinL}:{\over \LMIN\p{e_x, e_1 \cdots \LMIN\p{e_y, e_z} \cdots e_n}
\rightarrow \LMIN \p{ \LMIN \p{ e_x, e_1 \cdots e_y \cdots e_n}, e_1 \cdots e_z
\cdots e_n }
}\p{n\geq 0}
\end{align*}

\caption[]{Rewriting rules for \texttt{min}. Rewrite rules for \texttt{max} are
symmetrical. $e_x$, $e_y$, and $e_z$ represent expressions that contain a
variable $x$, $y$, and $z$, respectively.  The sequences $\p{e_k}_{k=1}^n$ are
independent of $e_x$, $e_y$, and $e_z$.} \label{figure:rewriting-logop}
\end{figure*}

\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Precedence} & \textbf{Operators} & \textbf{Fixity} \\ \hline
1 & \texttt{not}, \tilde & None \\\hline
2 & \texttt{pow} & Left \\\hline
3 & \texttt{*}, \texttt{/}, \texttt{\%} & Left \\\hline
4 & \texttt{+}, \texttt{-} & Left \\\hline
5 & \texttt{<{}<{}}, \texttt{>{}>{}} & Left \\\hline
6 & \texttt{<=}, \texttt{<}, \texttt{=} & None\footnotemark[2] \\\hline
7 & \texttt{\&}, \texttt{\^}, \texttt{|} & Left \\\hline
8 & \texttt{\&\&} & Left \\\hline
9 & \texttt{||} & Left \\\hline
10 & \texttt{if} & None \\\hline
\end{tabular}
\caption[]{The precedence and fixity of operators in L0. Lower precedence means
stronger binding.}
\label{table:precedence}
\end{table}

% \subsection{Generating variable constraints}

% If instead, $\oplus\p{x,y,c} = x\lt c \lp y \lt c$, and we would like to know
% whether $\oplus$ is associative wrt. $x$ and $y$, we reach no useful
% conclusion. We can find out whether there exists a $c$ for which this
% property holds:

% \begin{align*}
% x \lt c^2 \lp z \lt c &= x \lt c \lp z \lt c^2 \\
% x \lt c \lp z &= x \lp z \lt c \\
% x \lt c - z \lt c &= x - z \\
% c (x-z) &= x-z \\
% c &= {x-z\over x-z} \\
% c &= 1
% \end{align*}

% The compiler should at this point suggest that $c$ be replaced by a constant
% if the function is to be associative. Such an analysis may not reveal a
% constant, 

% This implies that $\oplus$ is associative for all $x$, $y$, and $z$ only if
% $\card{c}=1$. Of course, if $c$ is a constant, it is known to us, and the
% equality conclusion can be reached directly without solving for $c$.
