% L0 is a pure language

\section{Rewriting}

The straight-forward way of testing associativity is by \emph{rewriting}. We
can test whether $\oplus$ is associative by considering whether $\p{x \oplus y}
\oplus z$ and $x \oplus \p{y \oplus z}$ can be rewritten to be syntactically
equivalent.

For instance, if $\oplus\p{x,y} = x\lt c \lp y \lt c$, for some constant $c\in
S$, we consider whether the equality in \referToFigure{first-equality} holds
for all $x$, $y$, and $z$.

\begin{figure*}[htbp!]
\begin{align*}
\p{x\lt c \lp y\lt c}\lt c \lp z\lt c &= x\lt c \lp \p{y\lt c \lp z\lt c}\lt c \\
x\lt c \lt c \lp y\lt c \lt c \lp z\lt c &= x\lt c \lp y\lt c \lt c \lp z\lt c \lt c \\
x\lt c \lt c \lp z\lt c &= x\lt c \lp z\lt c \lt c
\end{align*}
\caption[]{If $\oplus\p{x,y}=x\lt c \lp y\lt c$ is associative, the above
should hold for all $x$, $y$ and $z$.}
\label{figure:first-equality}
\end{figure*}

This analysis requires \emph{rewriting} both expressions as a \emph{sum of
products}, followed by \emph{common term elimination}. If $c$ is a constant, we
can complete the analysis by \emph{constant folding}, and considering whether
the left-hand side is syntactically equivalent to the right-hand side.

Note, we didn't need to utilize the properties that addition and multiplication
are also commutative.  This is because the variables appear in the same order
on either side of the equality. So long as our rewriting rules respect this
order, we can proceed freely. 

Another property that our rewriting rules must respect are overflows. We should
keep in mind that we're dealing with modulo arithmetic.

We now specify the setup of the algorithm:

\begin{enumerate}

\item Let $f(x,y)=e$.

\item Let $z$ be a variable name that does not appear in $e$.

\item Let $e_1$ be a copy of $e$.

\item Let $e_2$ be a copy of $e$, where all occurrences of $y$ have been
replaced by $z$, and all occurrences of $x$ have been replaced by the program
text $\p{e_1}$ (in that order). Add all occurrences to $Q$.

\item Let $e_3$ be a copy of $e$, where all occurrences of $y$ have been
replaced by $z$, and all occurrences of $x$ have been replaced by $y$ (in that
order).

\item Let $e_4$ be a copy of $e$, where all occurrences of $y$ have been
replaced by the program text $\p{e_3}$. Add all occurrences to $Q$.

\item Use $Q$ to determine whether $e_2$ and $e_4$ are semantically equivalent.

\end{enumerate}

For instance, if $f(x,y)=x\lt c \lp y\lt c$:

\begin{align*}
e_1 &= x\lt c \lp y\lt c \\
e_2 &= \underbrace{\p{x\lt c \lp y\lt c} \lt c}_{q_1} \lp z \lt c \\
e_3 &= y\lt c \lp z \lt c \\
e_4 &= x \lt c \lp \underbrace{\p{ y \lt c \lp z \lt c } \lt c}_{q_2} \\
Q &= \seq{q_1, q_2 }
\end{align*}

$Q$ is a working queue which we will use to attempt to rewrite $e_2$ and $e_4$
into syntactically equivalent program texts. We proceed to rewrite the
subexpressions $q_1$ and $q_2$ by applying a rewrite rule. A rewrite rule will
typically introduces new parentheses, which designate smaller subexpressions to
be further rewritten.

For instance, from the precedence rules in \referToTable{precedence} and
\referToFigure{rewriting-arithop}, we see that for $q_1$ in the example above
we apply the rule $\proc{P-Times-Plus-R}$. This rewrites $q_1$ into

\[\underbrace{\p{x \lt c \lt c}}_{q_3} \lp \underbrace{\p{y \lt c \lt
c}}_{q_4},\]

where $q_3$ and $q_4$ get queued for rewriting. $q_3$ and $q_4$ both fall prey
to the associative chaining property of multiplication.
\referToFigure{rewriting-chaining} indicates that we rewrite such chains to be
right-associative. If no rewrite rules match a subexpression on the queue, the
subexpression is simply popped from the queue.

The algorithm terminates if there are no circular rewrites. This can be checked
by building a rewrite graph where the nodes are the rewrite rules. There is a
directed edge from one rewrite rule to another if the rewrite leads to a
program text rewritable by the other. If there are no cycles in this graph, the
finite nature of syntax trees of finite programs makes the algorithm terminate.

\subsection{Rewrite rules}

The general algorithm: is the operator chain-associative? is the operator
distributive over any other operators in L0?

We summarise the rules for arithmetic operators in
\referToFigure{rewriting-arithop}. The approach to constructing the rules in
general is to consider every operator $\oplus$, associative under chaining. For
each $\oplus$ we consider whether the $\oplus$ is distributive under every
$\otimes$. This will allow us to apply the rules by following the rules of
precedence of the language. We add an additional rule to transform chains.

We don't need to define rules for expanding parentheses over non-assoc
operators, as such functions won't associate anyways.

\begin{figure*}[htbp!]

\[
\begin{matrix}
\proc{P-Plus-Plus}:{\over
\p{e_1 \lp e_2}\lp e \rightarrow e_1 \lp \p{ e_2 \lp e }
}\\
\proc{P-Times-Times}:{\over
\p{e_1\lt e_2}\lt e \rightarrow e_1 \lt \p{ e_2 \lt e }
}\\
\end{matrix}
\]
\caption[]{Rewriting rules for operators that are associative under chaining.}
\label{figure:rewriting-chaining}
\end{figure*}


\begin{figure*}[htbp!]

\[
\begin{matrix}
\proc{P-Plus-Minus-R}:{\over
\p{e_1 \lm e_2}\lp e \rightarrow e_1 + \p{\lneg e2 \lp e}
}\\
\proc{P-Times-Mod-R}:{\over
\p{e_1 \lmod e_2}\lt e \rightarrow \p{ e_1 \lt e } \lmod \p{ e_2 \lt e }
}\\
\proc{P-Times-Plus-R}:{\over
\p{e_1 \lp e_2}\lt e \rightarrow \p{ e_1 \lt e } \lp \p{ e_2 \lt e }
}\\
\proc{P-Times-Minus-R}:{\over
\p{e_1 \lm e_2}\lt e \rightarrow \p{ e_1 \lt e } \lp \lneg\p{ e_2 \lt e }
}\\
\proc{P-Times-ShiftL-R}:{\over
\p{e_1 \LBSL e_2}\lt e \rightarrow \p{ e_1 \lt e } \LBSL e_2
}\\
\end{matrix}
\]
\caption[]{Rewriting rules for arithmetic operators. The above are only
right-distributions. Left-distributions are symmetrical. Note, bit shifting to
the left by $e$ is equivalent to multiplying by $2^e$.}
\label{figure:rewriting-arithop}
\end{figure*}


%\begin{figure*}[htbp!]

%\begin{align*}
%\proc{P-PlusR}:{\over
%\p{e_1 \lp e_2 \lp \cdots \lp e_n} \lp e \rightarrow e_1 \lp e_2 \lp \cdots \lp e_n \lp e
%}\p{n\geq 2}\\
%\proc{P-PlusL}:{\over
%e \lp \p{e_1 \lp e_2 \lp \cdots \lp e_n} \rightarrow e \lp e_1 \lp e_2 \lp \cdots \lp e_n
%}\p{n\geq 2}
%\end{align*}

%\begin{align*}
%\proc{P-TimesR}:{\over
%\p{e_1 \lp e_2 \lp \cdots \lp e_n} \lt e \rightarrow e_1\lt e \lp e_2\lt e \lp
%\cdots \lp e_n \lt e
%}\p{n\geq 2}\\
%\proc{P-TimesL}:{\over
%e\lt\p{e_1 \lp e_2 \lp \cdots \lp e_n} \rightarrow e\lt e_1 \lp e\lt e_2 \lp \cdots
%\lp e\lt e_n
%}\p{n\geq 2}
%\end{align*}

%\begin{align*}
%\proc{Minus}:{\over
%e_1 \lm e_2 \rightarrow e_1 \lp \lneg e_2
%}
%\end{align*}

%\begin{align*}
%\proc{P-Negate}:{\over
%\lneg\p{e_1 \lp e_2 \lp \cdots \lp e_n} \rightarrow \lneg e_1 \lp \lneg e_2 \lp \cdots
%\lp \lneg e_n
%}\p{n\geq 2}
%\end{align*}


%\caption[]{Rewriting rules for arithmetic operators.}
%\label{figure:rewriting-arithop}
%\end{figure*}


%\begin{figure*}[htbp!]
%\begin{align*}
%\proc{P-AndR}:{\over
%\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \LAND e \rightarrow e_1\LAND e \LOR
%e_2\LAND e \LOR \cdots \LOR e_n \LAND e
%}\p{n\geq 2}\\
%\proc{P-AndL}:{\over
%e\LAND\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \rightarrow e\LAND e_1 \LOR e\LAND
%e_2 \LOR \cdots
%\LOR e\LAND e_n
%}\p{n\geq 2}
%\end{align*}

%\begin{align*}
%\proc{P-OrR}:{\over
%\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \LOR e \rightarrow e_1 \LOR e_2 \LOR
%\cdots \LOR e_n \LOR e
%}\p{n\geq 2}\\
%\proc{P-OrL}:{\over
%e \LOR \p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \rightarrow e \LOR e_1 \LOR e_2
%\LOR \cdots \LOR e_n
%}\p{n\geq 2}
%\end{align*}

%\begin{align*}
%\proc{P-Not}:{\over
%\LNOT\p{e_1 \LOR e_2 \LOR \cdots \LOR e_n} \rightarrow \LNOT e_1 \LOR \LNOT e_2
%\LOR \cdots \LOR \LNOT e_n
%}\p{n\geq 2}
%\end{align*}

%\caption[]{Rewriting rules for logical operators.}
%\label{figure:rewriting-logop}
%\end{figure*}

For bitwise operators we simply use Light's associativity test. 

For the \LMIN{} and \LMAX{} functions, the rewrite rules are a bit more
complicated. First off, we need to do some extra work

\begin{figure*}[htbp!]
\begin{align*}
\proc{S-Min}:{\over \LMIN\p{e_y, e_x} \rightarrow \LMIN\p{e_x,e_y} }
\end{align*}

\begin{align*}
\proc{P-MinL}:{\over \LMIN\p{e_x, e_1 \cdots \LMIN\p{e_y, e_z} \cdots e_n}
\rightarrow \LMIN \p{ \LMIN \p{ e_x, e_1 \cdots e_y \cdots e_n}, e_1 \cdots e_z
\cdots e_n }
}\p{n\geq 0}
\end{align*}

\caption[]{Rewriting rules for \texttt{min}. Rewrite rules for \texttt{max} are
symmetrical. $e_x$, $e_y$, and $e_z$ represent expressions that contain a
variable $x$, $y$, and $z$, respectively.  The sequences $\p{e_k}_{k=1}^n$ are
independent of $e_x$, $e_y$, and $e_z$.} \label{figure:rewriting-logop}
\end{figure*}

\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Precedence} & \textbf{Operators} & \textbf{Fixity} \\ \hline
1 & \texttt{not}, \tilde & None \\\hline
2 & \texttt{pow} & Left \\\hline
3 & \texttt{*}, \texttt{/}, \texttt{\%} & Left \\\hline
4 & \texttt{+}, \texttt{-} & Left \\\hline
5 & \texttt{<{}<{}}, \texttt{>{}>{}} & Left \\\hline
6 & \texttt{<=}, \texttt{<}, \texttt{=} & None\footnotemark[2] \\\hline
7 & \texttt{\&}, \texttt{\^}, \texttt{|} & Left \\\hline
8 & \texttt{\&\&} & Left \\\hline
9 & \texttt{||} & Left \\\hline
10 & \texttt{if} & None \\\hline
\end{tabular}
\caption[]{The precedence and fixity of operators in L0. Lower precedence means
stronger binding.}
\label{table:precedence}
\end{table}

% \subsection{Generating variable constraints}

% If instead, $\oplus\p{x,y,c} = x\lt c \lp y \lt c$, and we would like to know
% whether $\oplus$ is associative wrt. $x$ and $y$, we reach no useful
% conclusion. We can find out whether there exists a $c$ for which this
% property holds:

% \begin{align*}
% x \lt c^2 \lp z \lt c &= x \lt c \lp z \lt c^2 \\
% x \lt c \lp z &= x \lp z \lt c \\
% x \lt c - z \lt c &= x - z \\
% c (x-z) &= x-z \\
% c &= {x-z\over x-z} \\
% c &= 1
% \end{align*}

% The compiler should at this point suggest that $c$ be replaced by a constant
% if the function is to be associative. Such an analysis may not reveal a
% constant, 

% This implies that $\oplus$ is associative for all $x$, $y$, and $z$ only if
% $\card{c}=1$. Of course, if $c$ is a constant, it is known to us, and the
% equality conclusion can be reached directly without solving for $c$.
