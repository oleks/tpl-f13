\section{Introduction}

An infix operator $\oplus:S\times S\rightarrow S$ is associative iff.
\[\forall\ x,y,z\in S\ .\ \p{x \oplus y} \oplus z = x \oplus \p{y \oplus z}.\]

One of the benefits of such functions is that a sequence of values
$\p{x_k}_{k=1}^n,\ x_k\in S$, can be aggregated into a single value $x\in S$,
using $n-1$ applications of $\oplus$, i.e. $x = x_1 \oplus \cdots \oplus
x_{n-1} \oplus x_n$. This is more commonly known as a \emph{reduction}.  For
instance, we can compute the sum of $n$ integers using $n-1$ binary additions.

A straight-forward reduction strategy is $\p{\cdots \p{\p{x_1 \oplus x_2}
\oplus x_3} \cdots \oplus x_{n-1}} \oplus x_n$, or equivalently, $x_1 \oplus
\p{x_2 \oplus \cdots \p{x_{n-2} \oplus \p{x_{n-1} \oplus x_n}} \cdots }$.  This
is known as a linear left or right \emph{fold}, respectively.

Reductions get more interesting on single-instruction multiple data (SIMD)
architectures. A reduction on a SIMD machine can be performed in parallel time
$O\p{\log n}$ on $n$ processors, or ${n/m}+O\p{\log m}$ on $m$ processors,
using a technique called \emph{parallel prefix scan}, or simply scan.

Scan is an interesting technique in and of itself as it can serve as a basic
building block in the design of parallel algorithms, replacing primitive
parallel memory referencing. If applicable, this technique typically reduces
the asymptotic bounds by a factor of $O\p{\log n}$\cite{blelloch}.

Scan takes an infix operator $\oplus:S\times S\rightarrow S$, an identity value
$i\in S$, such that $i\oplus i = i$, and a sequence $\p{x_k}_{k=1}^n,\ x_k\in
S$.  It produces the sequence $\p{i, x_1, x_1 \oplus x_2, \ldots, x_1 \oplus
\cdots \oplus x_{n-1} \oplus x_n}$.

To do this, parallel prefix scan performs a tree-like reduction rather than a
linear reduction. The sequence $\p{x_i \oplus x_{i+1}}_{i=1}^{n-1}$ is computed
first, by pairwise applying $\oplus$ to the elements of the sequence. The
sequence $\p{\p{x_i \oplus x_{i+1}} \oplus \p{x_{i+2} \oplus
x_{i+3}}}_{i=1}^{n-3}$ is computed second, by pairwise applying $\oplus$ to the
elements of the resulting sequence, and so on until a scalar is reached.

It is important for the correctness of the method that the function supplied to
scan is an associative function. The requirements could be relaxed to making
sure the function susceptible to tree-like reduction, but that would render the
functions identified by this method not necessarily suitable for linear
reductions. This would in turn discourage us from applying transformations to
turn linear reductions into tree-like reductions: we could speed up the program
by using parallel prefix scans rather than folds.

Most compilers will assume that the user has supplied an associative function.
Others will require for the function to be explicitly marked as
``associative''. Others still will try to deduce the associativity property,
and warn the user if the function isn't clearly associative. The last is
clearly preferable, especially for scientific computing languages such as L0,
since such a bug can be very hard to find (the user might not be aware that
associativity is a requirement at all).

\subsection{Undecidability}

Undecidability of the property is proven similar to the halting problem.

\begin{proof} We construct a binary Turing machine (TM) $M$ that takes as input
a pair of values $x,y\in S$.

Assume there exists a TM $A$, that given an binary TM $M$, accepts if $M$ is
associative, and rejects otherwise. That is, $A$ is a decider for the
associativity problem.

We construct $M$ such that it returns $x$ if $A(M)$ accepts, and a constant
$z\in S$ otherwise:

\[M\p{x,y} = \left\{ \begin{array}{l l} x & \text{if $A(M)$} \\ z &
\text{otherwise} \end{array} \right.\]

If $A(M)$ accepts, $M$ is not associative, if $A(M)$ rejects, $M$ is
associative, which contradicts our assumptions about $A$. \end{proof}

\subsection{The associative type}

For ease of analysis, we introduce the concept of the \emph{associative type}
--- a function type that unifies with the type of any associative function. We
identify this type from the following observation: an associative function
consumes at least two values of some type $S$, and returns a value of type $S$.

We define it formally as follows:

\[\oplus:S \boxtimes S \boxtimes T_1 \boxtimes T_2 \boxtimes \cdots \boxtimes
T_n \rightarrow S, \]

where

\begin{itemize}

\item $\p{T_k}_{k=1}^n$ for $n\geq 0$ is a sequence of arbitrary types.

\item $\boxtimes$ is the commutative equivalent of the regular $\times$, i.e.
the arguments to $\oplus$ can be rearranged under unification.

\end{itemize}

For example, the following types unify with the associative type: $f:S \times S
\times S \rightarrow S$, $g:S \times S \times \mathcal{Z} \rightarrow S$, $h:S
\times \mathcal{Z} \times S \rightarrow S$, etc.
